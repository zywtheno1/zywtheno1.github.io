<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Bambooleaf's blog]]></title>
  <subtitle><![CDATA[像竹子一样成长]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-06-22T02:00:49.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Bambooleaf]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[微信nodejs版]]></title>
    <link href="http://yoursite.com/2015/06/22/%E5%BE%AE%E4%BF%A1nodejs%E7%89%88/"/>
    <id>http://yoursite.com/2015/06/22/微信nodejs版/</id>
    <published>2015-06-22T01:57:49.000Z</published>
    <updated>2015-06-22T02:00:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>学习nodejs是从搭建hexo开始的，那时候每天还能写一篇日志，结果中间出差了一周，回来后状态全无，就变懒了……<br>好在我并没有彻底放弃学习node，有关于nodejs的学习一直没有停下来，最终算是完成了这个练手版的代码。<br>之所以用nodejs做微信，一是我的工作就是微信公众平台的开发，对这方面比较了解，还有就是nodejs本身非常适合做微信，于是就边学习node边把代码写出来了，所有代码基于测试号进行开发和调试。<br>（PS：本来是想申请一个订阅号的，结果坑爹的腾讯最近没办法申请注册个人的订阅号，总是卡在二维码认证那步，如果有哪位有办法解决感谢分享一下）</p>
<a id="more"></a>
<h1 id="学习感想">学习感想</h1><h2 id="参考代码及使用第三方组件">参考代码及使用第三方组件</h2><p>虽然对整个微信开发流程还算熟悉，但是在没人教的情况下还是很痛苦，很多小问题就要很久才能解决，所以很多地方都是参考了别人写的代码才完成的。</p>
<h3 id="webot">webot</h3><p>首先强烈推荐这个托管在github上的代码，<a href="https://github.com/node-webot。由一群大牛开发，覆盖了几乎现在微信的全部功能，而且还有针对分布式部署的优化，如果有人也要为公司开发微信公众号，强烈推荐这里面的代码。" target="_blank" rel="external">https://github.com/node-webot。由一群大牛开发，覆盖了几乎现在微信的全部功能，而且还有针对分布式部署的优化，如果有人也要为公司开发微信公众号，强烈推荐这里面的代码。</a></p>
<h3 id="bluebird">bluebird</h3><p>首先作为一个java程序猿，对js这种异步回调的机制还真是不太适应，所有的操作流都只能使用回调函数进行操作，看起来好像没什么，但是真正操作起来就会发现恶心到不行啊。</p>
<p><code>doAsync1(function () {
     doAsync2(function () {
       doAsync3(function () {
         doAsync4(function () {})
   })
   })
})</code> </p>
<p>这就是所谓的 “回调黑洞” 了。<br>无论是开发调试，还是要进行修改，都会出现各种让人心烦的感觉。具体的问题在这就不阐述了。<br>那么如何解决问题呢？<br>使用promise，具体请参考 <a href="http://segmentfault.com/a/1190000000586666" target="_blank" rel="external">深入理解 Promise 五部曲：1. 异步问题</a><br>而我最后选择的bluebird进行解决，地址为：<a href="https://www.npmjs.com/package/bluebird" target="_blank" rel="external">https://www.npmjs.com/package/bluebird</a><br>至于为什么我选用它，并不是我认为它有多好，而是我使用的另一个组件<a href="https://github.com/node-modules/urllib" target="_blank" rel="external">urllib</a> 里使用到了，所以我就顺便用了……</p>
<p>其中promise.map真是神器啊，谁用谁知道。</p>
<h3 id="cheerio">cheerio</h3><p>说实话我之前从来没写过爬虫的代码，但是自从我用了cheerio之后，爬个每日新闻什么的真是太容易啦</p>
<h3 id="socket-io">socket.io</h3><p>我不知道别的代码里socket通信有多麻烦，反正java里是很恶心就对了，不过socket.io真是做的太舒服了，其中我的代码里写了个简单的聊天室（为了学socket.io而写），让我对socket的操作有了更深的理解，但是我做的只是简单的广播通信，如果要做的复杂一些，比如指定两个人之间进行通信，创建自己的聊天室等复杂一些的功能，暂时我还真不知道怎么弄。<br>在此顺便感谢一下一个叫”千寻聊天室qx-chat-master”的作者（不好意思，，链接地址找不到了，package.json里也没留下什么），因为我的css基本就是小白，所以我直接使用了它的样式进行了一下删减。</p>
<h3 id="formstream">formstream</h3><p>地址：<a href="https://github.com/node-modules/formstream" target="_blank" rel="external">https://github.com/node-modules/formstream</a><br>nodejs里面如何模拟表单的提交？（微信的素材上传接口涉及到了这点）<br>网上查基本都是怎么处理接受来的请求，很少有怎么发送。</p>
<h3 id="later">later</h3><p>定时器这种东西，现在真是做的越来越简单了，java里面spring有整合，nodejs里面做的也是非常简单，这个later就是个强大的第三方组件，具体的操作规则可以参考：<a href="http://blog.fens.me/nodejs-cron-later/" target="_blank" rel="external">http://blog.fens.me/nodejs-cron-later/</a><br>这里面写的很详细了。</p>
<h3 id="其他">其他</h3><p>剩下的就是express，path等这些基本的了，整个学习过来真心觉得nodejs是不错的选择，不过我暂时只是学到了皮毛而已。我的代码里目前还没有数据库连接，没有日志，没有错误的处理等，可以优化的地方还很多，如果有时间我应该会进一步优化出一个版本，毕竟实践是检验学习的最好方法，只是看看书什么的（尤其是Node更新极快，市面上的书基本都是老版本的），根本没什么效果。</p>
<h1 id="代码结构">代码结构</h1><p>如果真的有人愿意看看我写的代码，我多少还是标注一下我写的东西吧。</p>
<ul>
<li>index.js<br>启动项，配置具体启用什么功能</li>
<li>chatRoom.js<br>聊天室的socket端代码</li>
<li>wechatAPI.js<br>用于主动请求微信公众平台，但是后来越做越乱，最后只是用来在链接后面添加个token，以后准备重新写。</li>
<li>wechatCheerio.js<br>爬虫代码，爬去的网页是it之家的页面，同时里面使用到了later，目前只是把内容存取到文件里<br>PS:里面已经完成了自动爬取内容，上传素材，群发的功能，但是最后一步因为是测试号而没法实现……</li>
<li>wechatConfig.js<br>公众号的相关配置都在这里面，比如appid等<br>（当时还没有学会promise，所以用的还是回调）</li>
<li>wechatProcess.js<br>与用户交互的报文的处理，目前将全部的文本消息都转向了图灵机器人处理</li>
</ul>
<h1 id="代码地址">代码地址</h1><p>github:<a href="https://github.com/bambooleaf/wechat_node" target="_blank" rel="external">https://github.com/bambooleaf/wechat_node</a><br>代码有些乱，大牛轻喷<br>还有我的个人博客 http:blog.bambooleaf.wang，欢迎学习交流</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>学习nodejs是从搭建hexo开始的，那时候每天还能写一篇日志，结果中间出差了一周，回来后状态全无，就变懒了……<br>好在我并没有彻底放弃学习node，有关于nodejs的学习一直没有停下来，最终算是完成了这个练手版的代码。<br>之所以用nodejs做微信，一是我的工作就是微信公众平台的开发，对这方面比较了解，还有就是nodejs本身非常适合做微信，于是就边学习node边把代码写出来了，所有代码基于测试号进行开发和调试。<br>（PS：本来是想申请一个订阅号的，结果坑爹的腾讯最近没办法申请注册个人的订阅号，总是卡在二维码认证那步，如果有哪位有办法解决感谢分享一下）</p>]]>
    
    </summary>
    
      <category term="nodejs wechat" scheme="http://yoursite.com/tags/nodejs-wechat/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[windows 下安装mongodb]]></title>
    <link href="http://yoursite.com/2015/05/23/windows-%E4%B8%8B%E5%AE%89%E8%A3%85mongodb/"/>
    <id>http://yoursite.com/2015/05/23/windows-下安装mongodb/</id>
    <published>2015-05-23T13:39:38.000Z</published>
    <updated>2015-05-23T13:45:10.000Z</updated>
    <content type="html"><![CDATA[<p>转自：<a href="http://www.cnblogs.com/lecaf/archive/2013/08/23/mongodb.html" target="_blank" rel="external">http://www.cnblogs.com/lecaf/archive/2013/08/23/mongodb.html</a></p>
<h1 id="windows下mongodb安装与使用整理">windows下mongodb安装与使用整理</h1><h2 id="首先安装mongodb">首先安装mongodb</h2><p>1.下载地址：<a href="http://www.mongodb.org/downloads" target="_blank" rel="external">http://www.mongodb.org/downloads</a></p>
<p>2.解压缩到自己想要安装的目录，比如d:\mongodb</p>
<p>3.创建文件夹d:\mongodb\data\db、d:\mongodb\data\log，分别用来安装db和日志文件，在log文件夹下创建一个日志文件MongoDB.log，即d:\mongodb\data\log\MongoDB.log</p>
<a id="more"></a>
<p>4.运行cmd.exe进入dos命令界面，执行下列命令</p>
<p>　　&gt; cd d:\mongodb\bin</p>
<p>　　&gt; d:\mongodb\bin&gt;mongod -dbpath “d:\mongodb\data\db”</p>
<p><img src="http://images.cnitblog.com/blog/203292/201308/21110329-868b0d1fb023479f9a605fc8353515f2.png" alt="启动信息"></p>
<p>　看到类似的信息，则说明启动成功，默认MongoDB监听的端口是27017，mysql的是3306</p>
<p>5.测试连接</p>
<p>　新开一个cmd窗口，进入mongodb的bin目录，输入mongo或者mongo.exe，出现如下信息说明测试通过，此时我们已经进入了test这个数据库，如何进入其他数据库下面会说。</p>
<p>　<img src="http://images.cnitblog.com/blog/203292/201308/21111025-91a3b6a9bde844688300928f0a9ea26f.png" alt="测试连接图片"></p>
<p>　输入exit或者ctrl+C可退出。</p>
<p> 6.当mongod.exe被关闭时，mongo.exe 就无法连接到数据库了，因此每次想使用mongodb数据库都要开启mongod.exe程序，所以比较麻烦，此时我们可以将MongoDB安装为windows服务</p>
<p>　还是运行cmd，进入bin文件夹，执行下列命令</p>
<p>　&gt; d:\mongodb\bin&gt;mongod —dbpath “d:\mongodb\data\db” —logpath “d:\mongodb\data\log\MongoDB.log” —install —serviceName “MongoDB”</p>
<p>　这里MongoDB.log就是开始建立的日志文件，—serviceName “MongoDB” 服务名为MongoDB</p>
<p>　接着启动mongodb服务</p>
<p>　&gt; d:\mongodb\bin&gt;NET START MongoDB</p>
<p>　<img src="http://images.cnitblog.com/blog/203292/201308/21161507-c374a9f43c1c4c75aeb9cc4ff83ef463.jpg" alt="启动服务"></p>
<p>　打开任务管理器，可以看到进程已经启动</p>
<p>7.关闭服务和删除进程</p>
<p>　&gt; d:\mongodb\bin&gt;NET stop MongoDB   (关闭服务)</p>
<p>　&gt; d:\mongodb\bin&gt;mongod —dbpath “d:\mongodb\data\db” —logpath “d:\mongodb\data\log\MongoDB.log” —remove —serviceName “MongoDB”      (删除，注意不是—install了）</p>
<h2 id="使用mongodb">使用mongodb</h2><p>1.常用的命令</p>
<p>show dbs    显示数据库列表<br>use dbname    进入dbname数据库，大小写敏感，没有这个数据库也不要紧<br>show collections    显示数据库中的集合，相当于表格<br>2.创建&amp;新增</p>
<p>db.users.save({“name”:”lecaf”})    创建了名为users的集合，并新增了一条{“name”:”lecaf”}的数据<br>db.users.insert({“name”:”ghost”, “age”:10})    在users集合中插入一条新数据，，如果没有users这个集合，mongodb会自动创建<br>save()和insert()也存在着些许区别：若新增的数据主键已经存在，insert()会不做操作并提示错误，而save() 则更改原来的内容为新内容。<br>存在数据：{ _id : 1, “ name “ : “ n1 “} ，_id是主键<br>insert({ _id : 1, “ name “ : “ n2 “ })    会提示错误<br>save({ _id : 1, “ name “ : “ n2 “ })     会把 n1 改为  n2 ，有update的作用。<br>3.删除</p>
<p>db.users.remove()    删除users集合下所有数据<br>db.users.remove({“name”: “lecaf”})    删除users集合下name=lecaf的数据<br>db.users.drop()或db.runCommand({“drop”,”users”})    删除集合users<br>db.runCommand({“dropDatabase”: 1})    删除当前数据库<br>4.查找</p>
<p>db.users.find()    查找users集合中所有数据<br>db.users.findOne()    查找users集合中的第一条数据<br>5.修改<br><img src="http://images.cnitblog.com/blog/203292/201308/22143209-cddea033063e480bb1bd4cc5dfdf9f4e.jpg" alt="效果图"><br>db.users.update({“name”:”lecaf”}, {“age”:10})    修改name=lecaf的数据为age=10，第一个参数是查找条件，第二个参数是修改内容，除了主键，其他内容会被第二个参数的内容替换，主键不能修改，如图
　</p>
<h2 id="高级应用">高级应用</h2><p>1.条件查找<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(&#123; <span class="string">"key"</span> : <span class="built_in">value</span> &#125;)    查找<span class="built_in">key</span>=<span class="built_in">value</span>的数据</span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span> : &#123; $gt: <span class="built_in">value</span> &#125; &#125;)    <span class="built_in">key</span> &gt; <span class="built_in">value</span></span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span> : &#123; $lt: <span class="built_in">value</span> &#125; &#125;)    <span class="built_in">key</span> &lt; <span class="built_in">value</span></span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span> : &#123; $gte: <span class="built_in">value</span> &#125; &#125;)    <span class="built_in">key</span> &gt;= <span class="built_in">value</span></span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span> : &#123; $lte: <span class="built_in">value</span> &#125; &#125;)    <span class="built_in">key</span> &lt;= <span class="built_in">value</span></span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span> : &#123; $gt: value1 , $lt: value2 &#125; &#125;)    value1 &lt; <span class="built_in">key</span> &lt;value2</span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span> : &#123; $ne: <span class="built_in">value</span> &#125; &#125;)    <span class="built_in">key</span> &lt;&gt; <span class="built_in">value</span></span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span> : &#123; $<span class="built_in">mod</span> : [ <span class="number">10</span> , <span class="number">1</span> ] &#125; &#125;)    取模运算，条件相当于<span class="built_in">key</span> % <span class="number">10</span> == <span class="number">1</span> 即<span class="built_in">key</span>除以<span class="number">10</span>余数为<span class="number">1</span>的</span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span> : &#123; $nin: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] &#125; &#125;)    不属于，条件相当于<span class="built_in">key</span>的值不属于[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]中任何一个</span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span> : &#123; $in: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] &#125; &#125;)    属于，条件相当于<span class="built_in">key</span>等于[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]中任何一个</span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span> : &#123; $size: <span class="number">1</span> &#125; &#125;)    $size 数量、尺寸，条件相当于<span class="built_in">key</span>的值的数量是<span class="number">1</span>（<span class="built_in">key</span>必须是数组，一个值的情况不能算是数量为<span class="number">1</span>的数组）</span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span> : &#123; $exists : true|false &#125; &#125;)    $exists 字段存在，true返回存在字段<span class="built_in">key</span>的数据，false返回不存在字度<span class="built_in">key</span>的数据</span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span>: /^val.*val$/i &#125;)    正则，类似like；“i”忽略大小写，“m”支持多行</span><br><span class="line">db.collection.find(&#123; $<span class="built_in">or</span> : [&#123;a : <span class="number">1</span>&#125;, &#123;b : <span class="number">2</span>&#125; ] &#125;)    $<span class="built_in">or</span>或 （注意：MongoDB <span class="number">1.5</span>.3后版本可用），符合条件a=<span class="number">1</span>的或者符合条件b=<span class="number">2</span>的数据都会查询出来</span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span>: <span class="built_in">value</span> , $<span class="built_in">or</span> : [&#123; a : <span class="number">1</span> &#125; , &#123; b : <span class="number">2</span> &#125;] &#125;)    符合条件<span class="built_in">key</span>=<span class="built_in">value</span> ，同时符合其他两个条件中任意一个的数据</span><br><span class="line">db.collection.find(&#123; <span class="string">"key.subkey"</span> :<span class="built_in">value</span> &#125;)    内嵌对象中的值匹配，注意：<span class="string">"key.subkey"</span>必须加引号</span><br><span class="line">db.collection.find(&#123; <span class="string">"key"</span>: &#123; $<span class="built_in">not</span> : /^val.*val$/i &#125; &#125;)    这是一个与其他查询条件组合使用的操作符，不会单独使用。上述查询条件得到的结果集加上$<span class="built_in">not</span>之后就能获得相反的集合。</span><br></pre></td></tr></table></figure></p>
<p>2.排序</p>
<p>db.collection.find().sort({ “key1” : -1 ,”key2” : 1 })    这里的1代表升序，-1代表降序<br>3.其他</p>
<p>db.collection.find().limit(5)    控制返回结果数量，如果参数是0，则当作没有约束，limit()将不起作用<br>db.collection.find().skip(5)    控制返回结果跳过多少数量，如果参数是0，则当作没有约束，skip()将不起作用，或者说跳过了0条<br>db.collection.find().skip(5).limit(5)    可用来做分页，跳过5条数据再取5条数据<br>db.collection.find().count(true)    count()返回结果集的条数<br>db.collection.find().skip(5).limit(5).count(true)    在加入skip()和limit()这两个操作时，要获得实际返回的结果数，需要一个参数true，否则返回的是符合查询条件的结果总数</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>转自：<a href="http://www.cnblogs.com/lecaf/archive/2013/08/23/mongodb.html">http://www.cnblogs.com/lecaf/archive/2013/08/23/mongodb.html</a></p>
<h1 id="windows下mongodb安装与使用整理">windows下mongodb安装与使用整理</h1><h2 id="首先安装mongodb">首先安装mongodb</h2><p>1.下载地址：<a href="http://www.mongodb.org/downloads">http://www.mongodb.org/downloads</a></p>
<p>2.解压缩到自己想要安装的目录，比如d:\mongodb</p>
<p>3.创建文件夹d:\mongodb\data\db、d:\mongodb\data\log，分别用来安装db和日志文件，在log文件夹下创建一个日志文件MongoDB.log，即d:\mongodb\data\log\MongoDB.log</p>]]>
    
    </summary>
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
      <category term="转载文章" scheme="http://yoursite.com/categories/%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ubuntu安装sublime2]]></title>
    <link href="http://yoursite.com/2015/05/23/ubuntu%E5%AE%89%E8%A3%85sublime2/"/>
    <id>http://yoursite.com/2015/05/23/ubuntu安装sublime2/</id>
    <published>2015-05-23T05:10:19.000Z</published>
    <updated>2015-05-23T05:33:06.000Z</updated>
    <content type="html"><![CDATA[<p>学习nodejs，也顺带着学习使用linux，但是在开发工具上悲剧了，以前用习惯了sublime，所以在linux上也要安装一个，结果就是好坑……</p>
<h1 id="linux下安装sublime2流程">linux下安装sublime2流程</h1><h2 id="安装sublime2">安装sublime2</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="instruction"> add-apt-repository </span>ppa:webupd8team/sublime-text-2</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text</span><br><span class="line"></span><br><span class="line">//网上写的是sudo apt-get install sublime-text-2,可是在我安装的时候提示sublime2已经合并到sublime里面了，所以安装出来的就是sublime2</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在ubuntu系统下，安装成功后随便找个文档，右键==&gt;打开方式==&gt;sublime text 2<br>说明安装成功了</p>
<h2 id="安装Package_Control">安装Package Control</h2><p>sublime2最收欢迎的就是各种各样的插件了<br>在这里记录下我安装的全流程</p>
<p>1,按Ctrl+`调出console<br>2,粘贴以下代码到底部命令行并回车：<br>import urllib2,os;pf=’Package Control.sublime-package’;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),’wb’).write(urllib2.urlopen(‘<a href="http://sublime.wbond.net/&#39;+pf.replace(" target="_blank" rel="external">http://sublime.wbond.net/&#39;+pf.replace(</a>‘ ‘,’%20’)).read())<br>3,重启Sublime Text 2。</p>
<h2 id="用Package_Control安装插件的方法">用Package Control安装插件的方法</h2><p>按下Ctrl+Shift+P调出命令面板<br>输入install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。</p>
<p>更多插件安装可参考<a href="http://www.linuxidc.com/Linux/2013-08/89451.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2013-08/89451.htm</a><br>或<a href="http://www.cnblogs.com/wangcan/p/3845268.html" target="_blank" rel="external">http://www.cnblogs.com/wangcan/p/3845268.html</a></p>
<h2 id="中文输入法问题">中文输入法问题</h2><p>ubuntu下，sublime的中文输入有问题，我就懒得解决了，因为我用的是ibus……<br>看看以后是换成webstorm还是微软的visio studio code吧</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习nodejs，也顺带着学习使用linux，但是在开发工具上悲剧了，以前用习惯了sublime，所以在linux上也要安装一个，结果就是好坑……</p>
<h1 id="linux下安装sublime2流程">linux下安装sublime2流程</h1><h2 id="安装sublime2">安装sublime2</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="instruction"> add-apt-repository </span>ppa:webupd8team/sublime-text-2</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text</span><br><span class="line"></span><br><span class="line">//网上写的是sudo apt-get install sublime-text-2,可是在我安装的时候提示sublime2已经合并到sublime里面了，所以安装出来的就是sublime2</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="sublime2" scheme="http://yoursite.com/tags/sublime2/"/>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mongodb课堂笔记]]></title>
    <link href="http://yoursite.com/2015/05/23/mongodb%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2015/05/23/mongodb课堂笔记/</id>
    <published>2015-05-22T23:44:03.000Z</published>
    <updated>2015-05-22T23:45:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="索引">索引</h1><h2 id="什么是索引">什么是索引</h2><p>特殊的数据结构，按照顺序保存文档中的一个或多个指定。<br>使用B-Tree索引，方便范围查询和匹配查询。<br><img src="http://7xj22g.com1.z0.glb.clouddn.com/zhufeng%E7%B4%A2%E5%BC%95.jpg" alt="索引建立原理"><br>各种类型都可以建立索引，比如字符串可以按照ASCII码建立</p>
<h1 id="建立索引">建立索引</h1><p>（一下代码为在线课堂听课时，一边听一边打在记事本上的，所以一下代码仅供参考）<br><a id="more"></a></p>
<h2 id="插入数据">插入数据</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for<span class="list">(<span class="keyword">var</span> i=0<span class="comment">;i&lt;300000;i++)&#123;</span></span><br><span class="line">    db.persons.insert<span class="list">(<span class="keyword">name</span><span class="keyword">:i</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="创建匿名索引">创建匿名索引</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">db</span><span class="class">.persons</span><span class="class">.ensureIndex</span>(&#123;<span class="attribute">name</span>:<span class="number">1</span>&#125;)<span class="comment">//从小到大排列</span></span><br></pre></td></tr></table></figure>
<h2 id="创建命名索引">创建命名索引</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.persons.ensuerIndex(&#123;<span class="property">name</span>:<span class="number">1</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"indexName"</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>(PS:前面的name表示的是数据的属性，后面的”name”表示的是索引的属性)</p>
<h2 id="分析索引的执行过程">分析索引的执行过程</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">db</span><span class="class">.persons</span><span class="class">.find</span>(&#123;<span class="attribute">name</span>:<span class="number">100000</span>&#125;)<span class="class">.explain</span>();</span><br></pre></td></tr></table></figure>
<p>使用索引前后对比</p>
<p><img src="http://7xj22g.com1.z0.glb.clouddn.com/zhufeng%E7%B4%A2%E5%BC%952.png" alt="使用索引前"><br><img src="http://7xj22g.com1.z0.glb.clouddn.com/zhufeng%E7%B4%A2%E5%BC%953.png" alt="使用索引后"></p>
<h2 id="指定使用的索引">指定使用的索引</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">db</span><span class="class">.persons</span><span class="class">.find</span>(&#123;<span class="tag">name</span><span class="pseudo">:1</span>&#125;)<span class="class">.hint</span>(&#123;<span class="attribute">name</span>:-<span class="number">1</span>&#125;)<span class="class">.explain</span>();</span><br></pre></td></tr></table></figure>
<h2 id="删除所有索引">删除所有索引</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">db</span><span class="class">.runCommand</span>(&#123;<span class="attribute">dropIndexes</span>:<span class="string">"person"</span>,<span class="attribute">index</span>:<span class="string">"*"</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="多键索引">多键索引</h2><p>自动对数组进行索引<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.person.insert(&#123;<span class="symbol">hobby:</span>[<span class="string">'basketball'</span>,<span class="string">'</span><br><span class="line">football'</span>,<span class="string">'pingpang'</span>]&#125;);</span><br><span class="line">db.person.ensureIndex(&#123;<span class="symbol">hobby:</span><span class="number">1</span>&#125;);</span><br><span class="line">db.person.find(&#123;hobby;<span class="string">'football'</span>&#125;,&#123;<span class="symbol">hobby:</span><span class="number">1</span>，<span class="constant">_id:</span><span class="number">0</span>&#125;).explain();<span class="regexp">//find</span>的第二个参数表示是否返回某个字段</span><br></pre></td></tr></table></figure></p>
<h2 id="复合索引">复合索引</h2><p>查询条件不止一个，需要用复合索引<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">db</span><span class="class">.p</span><span class="class">.insert</span>(&#123;<span class="tag">a</span><span class="pseudo">:1</span>,<span class="tag">b</span><span class="pseudo">:2</span>&#125;)</span><br><span class="line"><span class="tag">db</span><span class="class">.p</span><span class="class">.insert</span>(&#123;<span class="tag">a</span><span class="pseudo">:2</span>,<span class="tag">b</span><span class="pseudo">:3</span>&#125;)</span><br><span class="line"><span class="tag">db</span><span class="class">.p</span><span class="class">.find</span>(&#123;<span class="attribute">a</span>:<span class="number">1</span>,<span class="attribute">b</span>:<span class="number">2</span>&#125;)<span class="class">.explain</span>();</span><br><span class="line"><span class="tag">db</span><span class="class">.p</span><span class="class">.ensureIndex</span>(&#123;<span class="attribute">a</span>:<span class="number">1</span>,<span class="attribute">b</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="tag">db</span><span class="class">.p</span><span class="class">.find</span>(&#123;<span class="tag">a</span><span class="pseudo">:1</span>,<span class="tag">b</span><span class="pseudo">:2</span>&#125;,&#123;<span class="attribute">a</span>:<span class="number">1</span>,<span class="attribute">_id</span>:<span class="number">0</span>&#125;)<span class="class">.explain</span>();</span><br></pre></td></tr></table></figure></p>
<h2 id="过期索引">过期索引</h2><p>在一定的时间后会过期，过期后，相应的数据被删除<br>用于session、日志、缓存、临时文件<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">db</span><span class="class">.p2</span><span class="class">.insert</span>(&#123;<span class="attribute">time</span>:new <span class="function">Date</span>()&#125;);</span><br><span class="line"><span class="tag">db</span><span class="class">.p2</span><span class="class">.insert</span>(&#123;<span class="attribute">time</span>:new <span class="function">Date</span>()&#125;);</span><br><span class="line"><span class="tag">db</span><span class="class">.p2</span><span class="class">.ensureIndex</span>(&#123;<span class="tag">time</span><span class="pseudo">:1</span>&#125;,&#123;<span class="attribute">expireAfterSeconds</span>:<span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意：<br>1，索引字段的值，必须是Date对象，不能是其他类型，比如时间戳<br>2，删除时间不精确，每60秒跑一次，删除也是需要时间的，所以会存在一些误差</p>
<h2 id="二维索引">二维索引</h2><p>空间索引，可以查询一定范围内的地理坐标<br><img src="http://7xj22g.com1.z0.glb.clouddn.com/zhufeng%E7%B4%A2%E5%BC%954.png" alt="二位索引"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> j =<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)&#123;</span><br><span class="line">    	db.<span class="keyword">map</span>.insert(&#123;gis:&#123;x:i,y:j&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">db.<span class="keyword">map</span>.ensuerIndex(&#123;gis:<span class="string">'2d'</span>&#125;);<span class="comment">//注意此处类型为2d</span></span><br></pre></td></tr></table></figure></p>
<h3 id="查询距离[1,1]最近的点">查询距离[1,1]最近的点</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">db</span><span class="class">.map</span><span class="class">.find</span>(&#123;<span class="tag">gis</span>:&#123;$<span class="tag">near</span>:<span class="attr_selector">[1,1]</span>&#125;,&#123;<span class="attribute">gis</span>:<span class="number">1</span>,<span class="attribute">_id</span>:<span class="number">0</span>&#125;&#125;)<span class="class">.limit</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h3 id="查询以[1,1]和[3,3]为对角线的矩形里的所有点">查询以[1,1]和[3,3]为对角线的矩形里的所有点</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">db</span><span class="class">.map</span><span class="class">.find</span>(&#123;<span class="tag">gis</span>:&#123;$<span class="tag">within</span>:&#123;$<span class="tag">center</span>:<span class="attr_selector">[[1,1]</span>,<span class="attr_selector">[3,3]</span>]&#125;,&#123;<span class="attribute">gis</span>:<span class="number">1</span>,<span class="attribute">_id</span>:<span class="number">0</span>&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="查询以圆心[1,1]，半径为1的圆形里面的所有点">查询以圆心[1,1]，半径为1的圆形里面的所有点</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">db</span><span class="class">.map</span><span class="class">.find</span>(&#123;<span class="tag">gis</span>:&#123;$<span class="tag">within</span>:&#123;$<span class="tag">center</span>:<span class="attr_selector">[[1,1]</span>,<span class="tag">1</span>]&#125;&#125;,&#123;<span class="attribute">gis</span>:<span class="number">1</span>,<span class="attribute">_id</span>:<span class="number">0</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="多边形">多边形</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">db</span><span class="class">.map</span><span class="class">.find</span>(&#123;<span class="tag">gis</span>:&#123;$<span class="tag">within</span>:&#123;$<span class="tag">polygon</span>:<span class="attr_selector">[[2,1]</span>,<span class="attr_selector">[1,3]</span>,<span class="attr_selector">[3,1]</span>]&#125;&#125;,&#123;<span class="attribute">gis</span>:<span class="number">1</span>,<span class="attribute">_id</span>:<span class="number">0</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="索引注意事项">索引注意事项</h1><p>1,1为正序，-1为倒序<br>2,索引虽然可以提升查询性能，但是会降低插入效率<br>3,索引一定要建立的合理</p>
<h1 id="主从复制">主从复制</h1><p>主从复制就是一个简单的数据库同步备份的集群技术<br>1,集群中需要指定主服务器<br>2,还需要从服务器，从服务器需要制定谁是他的主服务器</p>
<h2 id="配置">配置</h2><p>启动主服务器<br>mongod —dbpaht=/data/mongodb/master —port=8000 —master<br>启动从服务器<br>mongod —dbpath=/data/mongodb/slave —port=8001 —slave —source localhost:8000</p>
<h2 id="从服务器需要指定的重要选项">从服务器需要指定的重要选项</h2><ul>
<li>only 指定复制的数据库</li>
<li>slavedelay 主库向从库同步时的延迟时间</li>
<li>oplogSize 主节点操作记录存储到Local的oplog里，从服务器从主服务器上取回这个日志文件然后更新自己的数据库</li>
<li>autoresync是否自动同步所有数据，如果为true则自动同步所有数据，如果为false则只同步主从关系建立后的数据</li>
</ul>
<h1 id="副本集">副本集</h1><p>它是一个集群<br>当主服务器宕机后，其他的从服务器会根据权重算法选举出来一台从服务器作为新的主服务器，原主服务恢复后变成了从服务器，继续加入到当前的集群中</p>
<p><img src="http://7xj22g.com1.z0.glb.clouddn.com/zhufeng%E5%89%AF%E6%9C%AC%E9%9B%86.png" alt="副本集原理图"><br><img src="http://7xj22g.com1.z0.glb.clouddn.com/zhufeng%E5%89%AF%E6%9C%AC%E9%9B%862.png" alt="副本集原理图2"><br>主从的区别</p>
<p>从服务器默认shell下不能查询（可设置slaveOK=true或者用插件）</p>
<p>(PS:由于mongodb建立会之间占用一大块空间，所以在本地虚拟机进行测试的情况下请预留出足够的空间)<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir master</span><br><span class="line">mkdir slave1</span><br><span class="line">mkdir slave2</span><br><span class="line">mongod --dbpath=<span class="regexp">/data/</span>mongodb/master --port=<span class="number">8000</span> --replSet=groups --noprealloc</span><br><span class="line">mongod --dbpath=<span class="regexp">/data/</span>mongodb/master1 --port=<span class="number">8001</span> --replSet=groups --noprealloc</span><br><span class="line">mongod --dbpath=<span class="regexp">/data/</span>mongodb/master2 --port=<span class="number">8002</span> --replSet=groups --noprealloc</span><br><span class="line"><span class="comment">//此时没有指定master，会自动选举</span></span><br><span class="line"></span><br><span class="line">db.runCommand(&#123;<span class="string">replSetInitiate:</span>&#123;<span class="string">'_id'</span>:<span class="string">'groups'</span>,<span class="string">members:</span>[&#123;<span class="string">_id:</span><span class="number">1</span>,<span class="string">host:</span><span class="string">'127.0.0.1:8000'</span>，<span class="string">priority:</span><span class="number">0</span>&#125;,&#123;<span class="string">_id:</span><span class="number">2</span>,<span class="string">host:</span><span class="string">'127.0.0.1:8001'</span>&#125;,&#123;<span class="string">_id:</span><span class="number">3</span>,<span class="string">host:</span><span class="string">'127.0.0.1:8002'</span>&#125;]&#125;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>其中：<br>priority0-1000<br>0代表副本节点<br>1-1000是常规节点<br>arbiterOnly:true<br>另外还有一些其他参数</p>
<ul>
<li>standard 常规节点，参与投票，并且有可能成为主节点</li>
<li>passive 副本节点 参与投票，不能成为主要节点，进行复制</li>
<li>arbiter 仲裁节点 只参与投票，不能成为主节点，不能复制</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="索引">索引</h1><h2 id="什么是索引">什么是索引</h2><p>特殊的数据结构，按照顺序保存文档中的一个或多个指定。<br>使用B-Tree索引，方便范围查询和匹配查询。<br><img src="http://7xj22g.com1.z0.glb.clouddn.com/zhufeng%E7%B4%A2%E5%BC%95.jpg" alt="索引建立原理"><br>各种类型都可以建立索引，比如字符串可以按照ASCII码建立</p>
<h1 id="建立索引">建立索引</h1><p>（一下代码为在线课堂听课时，一边听一边打在记事本上的，所以一下代码仅供参考）<br>]]>
    
    </summary>
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CAS单点登录简介]]></title>
    <link href="http://yoursite.com/2015/05/20/CAS%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2015/05/20/CAS单点登录简介/</id>
    <published>2015-05-20T11:41:57.000Z</published>
    <updated>2015-05-20T11:42:54.000Z</updated>
    <content type="html"><![CDATA[<p>被借调到另一个项目组，发现他们使用了CAS单点登录，就借此机会了解一下，也许以后有机会用得上</p>
<p>CAS （ Central Authentication Service ） 是 Yale 大学发起的一个企业级的、开源的项目，旨在为 Web 应用系统提供一种可靠的单点登录解决方法（属于 Web SSO ）。<br>CAS 开始于 2001 年， 并在 2004 年 12 月正式成为 JA-SIG 的一个项目。</p>
<p>在网上找到一篇不错的文章<a href="http://www.coin163.com/java/cas/cas.html" target="_blank" rel="external">CAS实现SSO单点登录原理</a></p>
<p>具体配置信息可参考<a href="http://blog.csdn.net/small_love/article/details/6664831" target="_blank" rel="external">CAS实现单点登录（SSO）经典完整教程</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>被借调到另一个项目组，发现他们使用了CAS单点登录，就借此机会了解一下，也许以后有机会用得上</p>
<p>CAS （ Central Authentication Service ） 是 Yale 大学发起的一个企业级的、开源的项目，旨在为 Web 应用系统提供一种可靠的]]>
    </summary>
    
      <category term="CAS" scheme="http://yoursite.com/tags/CAS/"/>
    
      <category term="工作总结" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hibernate 工作总结]]></title>
    <link href="http://yoursite.com/2015/05/19/hibernate-%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2015/05/19/hibernate-工作总结/</id>
    <published>2015-05-19T13:57:02.000Z</published>
    <updated>2015-05-19T14:01:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="hibernate核心思想">hibernate核心思想</h1><p>整体理解可参考<a href="http://blog.csdn.net/wanghuan203/article/details/7526246" target="_blank" rel="external">hibernate整体理解</a><br>hibernate是一个采用ORM（Object/Relation Mapping对象关系映射）机制持久层的开源框架<br>    其主要核心思想是面向对象，而非面向过程，而这个面向对象则主要通过ORM实现。<br>    ORM是将表与表之间的操作，映射成对象和对象之间的操作，就是通过操作实体类来达到操作表的目的。从数据库提取的数据会自动按你设置的映射要求封装成特定的对象。之后你就可以通过对对象进行操作来修改数据库中的数据。<strong>这时候你面对的不是信息的碎片，而是一个形象鲜明的对象</strong>。<br><a id="more"></a><br>    hibernate一对一映射等映射可参考<a href="http://blog.csdn.net/wanghuan203/article/details/7566518" target="_blank" rel="external">实体类之间映射</a><br>    关于主要的主键生成策略，可参考<a href="http://blog.csdn.net/wanghuan203/article/details/7562395" target="_blank" rel="external">《Hibernate主键生成策略总结》</a></p>
<h1 id="Hibernate_Session_&amp;_Transaction详解">Hibernate Session &amp; Transaction详解</h1><h2 id="hibernate_的_session">hibernate 的 session</h2><p>Session是JAVA应用程序和Hibernate进行交互时使用的主要接口，它也是持久化操作核心API，<br>　　注意这里的Session的含义，它与传统意思上web层的HttpSession并没有关系，Hibernate Session之与Hibernate，相当于JDBC Connection相对与JDBC。<br>　　Session对象是有生命周期的，它以Transaction对象的事务开始和结束边界<br>　　Session作为贯穿Hibernate的持久化管理器核心，提供了众多的持久化的方法，如save(), update ,delete ,find(Hibernate 3中已经取消了此方法)等，通过这些方法我们可以透明的完成对象的增删改查（CRUD— create read update delete），这里所谓的透明是指，Session在读取，创建和删除影射的实体对象的实例时，这一系列的操作将被转换为对数据库表中数据的增加，修改，查询和删除操作。</p>
<p>SessionFactory负责创建Session，SessionFactory是线程安全的，多个并发线程可以同时访问一个SessionFactory 并从中获取Session实例。而Session并非线程安全，也就是说，如果多个线程同时使用一个Session实例进行数据存取，则将会导致Session 数据存取逻辑混乱.因此创建的Session实例必须在本地存取空上运行，使之总与当前的线程相关。</p>
<p>Session有以下的特点<br>　　1,不是线程安全的，应该避免多个线程共享同一个Session实例<br>　　2,Session实例是轻量级的，所谓轻量级：是指他的创建和删除不需要消耗太多资源<br>　　3,Session对象内部有一个缓存，被称为Hibernate第一缓存，他存放被当前工作单元中加载的对象，每个Session实例都有自己的缓存。<br>　　<br>Hibernate Session缓存被称为Hibernate的第一级缓存。SessionFactory的外置缓存称为Hibernate的二级缓存。这两个缓存都位于持久层，它们存放的都是数据库数据的拷贝。SessionFactory的内置缓存 存放元数据和预定义SQL， SessionFactory的内置缓存是只读缓存。</p>
<p>Hibernate Session缓存的三大作用：<br>1，减少数据库的访问频率，提高访问性能。<br>2，保证缓存中的对象与数据库同步，位于缓存中的对象称为持久化对象。<br>3，当持久化对象之间存在关联时，Session 保证不出现对象图的死锁。<br>Session 如何判断持久化对象的状态的改变呢？<br>Session 加载对象后会为对象值类型的属性复制一份快照。当Session 清理缓存时，比较当前对象和它的快照就可以知道那些属性发生了变化。</p>
<p>Session 什么时候清理缓存？<br>1，commit（） 方法被调用时<br>2，查询时会清理缓存，保证查询结果能反映对象的最新状态。<br>3，显示的调用session 的 flush方法。<br>session 清理缓存的特例：<br>当对象使用 native 生成器 时 会立刻清理缓存向数据库中插入记录。</p>
<h2 id="hibernate的Transanction">hibernate的Transanction</h2><p>Transanction接口是Hibernate的数据库事务接口，用于管理事务，他对底层的事务作出了封装，用户可以使用Transanction对象定义自己的对数据库的原子操作，底层事务包括：JDBC API ,JTA(Java Transaction API)。。。。。<br>　　一个Transaction对象的事务可能会包括多个对数据库进行的操作<br>　　org.hibernate Interface Transaction<br>　　public interface Transaction<br>常用方法：<br>　　public void commit() throws HibernateException 刷新当前的Session以及结束事务的工作，这个方法将迫使数据库对当前的事务进行提交<br>　　public void rollback() throws HibernateException ：强迫回滚当前事务<br>　　public boolean isActive() throws HibernateException： 这个事务是否存活<br><strong>在不同环境下transaction略有不同</strong><br>1、在JDBC上使用Hibernate </p>
<p>必须写上Hibernate Transaction代码，否则数据库没有反应。此时Hibernate的Transaction就是Connection.commit而已 </p>
<p>2、在JTA上使用Hibernate </p>
<p>写JTA的Transaction代码，不要写Hibernate的Transaction代码，否则程序会报错 </p>
<p>3、在EJB上使用Hibernate </p>
<p>什么Transactioin代码都不要写，在EJB的部署描述符里面配置 </p>
<p>参考：<a href="http://blog.163.com/magicc_love/blog/static/1858536622012092478227/" target="_blank" rel="external">http://blog.163.com/magicc_love/blog/static/1858536622012092478227/</a></p>
<h1 id="spring线程安全问题">spring线程安全问题</h1><p>Spring框架里的bean，或者说组件，获取实例的时候都是默认的单例模式，这是在多线程开发的时候要尤其注意的地方。那么spring是如何保证线程安全的呢？<br><strong>通过TheadLocal类</strong><br>具体内容可参考下面两篇文章<br><a href="http://blog.csdn.net/c289054531/article/details/9196053" target="_blank" rel="external">Spring单实例、多线程安全、事务解析</a><br><a href="http://www.cnblogs.com/doit8791/p/4093808.html" target="_blank" rel="external">Spring单例与线程安全小结</a></p>
<h1 id="配置多数据源">配置多数据源</h1><p>有人提到了这个问题，不过我没有实践过，所以就先在这里记下个解决方案，以后有机会去试试吧<a href="http://blog.csdn.net/linxuliang/article/details/7838132#comments" target="_blank" rel="external">Spring3+Hibernate3(Jpa)配置多个数据源的解决方案（基于注解）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="hibernate核心思想">hibernate核心思想</h1><p>整体理解可参考<a href="http://blog.csdn.net/wanghuan203/article/details/7526246">hibernate整体理解</a><br>hibernate是一个采用ORM（Object/Relation Mapping对象关系映射）机制持久层的开源框架<br>    其主要核心思想是面向对象，而非面向过程，而这个面向对象则主要通过ORM实现。<br>    ORM是将表与表之间的操作，映射成对象和对象之间的操作，就是通过操作实体类来达到操作表的目的。从数据库提取的数据会自动按你设置的映射要求封装成特定的对象。之后你就可以通过对对象进行操作来修改数据库中的数据。<strong>这时候你面对的不是信息的碎片，而是一个形象鲜明的对象</strong>。<br>]]>
    
    </summary>
    
      <category term="hibernate" scheme="http://yoursite.com/tags/hibernate/"/>
    
      <category term="工作总结" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javascript变量 作用域 内存]]></title>
    <link href="http://yoursite.com/2015/05/18/javascript%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2015/05/18/javascript变量-作用域-内存/</id>
    <published>2015-05-18T13:53:01.000Z</published>
    <updated>2015-05-18T13:57:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="基本类型和引用类型">基本类型和引用类型</h1><ul>
<li>只能给引用类型值动态地添加属性</li>
<li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；引用类型的值是对象，保存在堆内存中；</li>
<li>基本类型复制，是“真复制”，引用类型复制，复制的是“指针”</li>
<li>ECMAScript 中所有函数的参数都是按<strong>值传递</strong>的</li>
<li>检测类型</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> s = <span class="string">"Nicholas"</span>;</span><br><span class="line"> <span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">var</span> u;</span><br><span class="line"><span class="keyword">var</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">alert(<span class="keyword">typeof</span> s); <span class="comment">//string</span></span><br><span class="line">alert(<span class="keyword">typeof</span> i); <span class="comment">//number</span></span><br><span class="line">alert(<span class="keyword">typeof</span> b); <span class="comment">//boolean</span></span><br><span class="line">alert(<span class="keyword">typeof</span> u); <span class="comment">//undefined</span></span><br><span class="line">alert(<span class="keyword">typeof</span> n); <span class="comment">//object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> o); <span class="comment">//object</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p> 对于引用类型的检测，使用instanceof</p>
<ul>
<li>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。</li>
<li>延长作用域链<br>当执行try-catch 语句的catch 块，with 语句，作用域链会延长。</li>
<li>没有块级作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">alert(i); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>对于JavaScript 来说，由for 语句创建的变量i 即使在for 循环执行结束后，也依旧会存在<br>于循环外部的执行环境中。</p>
<ul>
<li>垃圾收集<br>标记清除，引用计数（存在循环引用的问题）</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="基本类型和引用类型">基本类型和引用类型</h1><ul>
<li>只能给引用类型值动态地添加属性</li>
<li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；引用类型的值是对象，保存在堆内存中；</li>
<li>基本类型复制，是“真复制”，引用类型复制，复制的是“指针”</li>
<li>ECMAScript 中所有函数的参数都是按<strong>值传递</strong>的</li>
<li>检测类型</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> s = <span class="string">"Nicholas"</span>;</span><br><span class="line"> <span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">var</span> u;</span><br><span class="line"><span class="keyword">var</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">alert(<span class="keyword">typeof</span> s); <span class="comment">//string</span></span><br><span class="line">alert(<span class="keyword">typeof</span> i); <span class="comment">//number</span></span><br><span class="line">alert(<span class="keyword">typeof</span> b); <span class="comment">//boolean</span></span><br><span class="line">alert(<span class="keyword">typeof</span> u); <span class="comment">//undefined</span></span><br><span class="line">alert(<span class="keyword">typeof</span> n); <span class="comment">//object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> o); <span class="comment">//object</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring 工作总结]]></title>
    <link href="http://yoursite.com/2015/05/18/spring-%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2015/05/18/spring-工作总结/</id>
    <published>2015-05-18T13:50:21.000Z</published>
    <updated>2015-05-18T13:51:52.000Z</updated>
    <content type="html"><![CDATA[<p>公司另一个项目组换框架，将要换成spring的框架，正好我之前做的项目用的spring，但是我本身也没有理解的多透彻。明天需要我去简单培训一下，所以我就借此机会好好复习一下了</p>
<h1 id="spring核心思想">spring核心思想</h1><h2 id="IOC（控制反转）">IOC（控制反转）</h2><p>  Spring容器来实现这些相互依赖对象的创建、协调工作。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了（IOC、DI）。<br><a id="more"></a><br>  所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。<br>  那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。<br>  具体文章解释，我觉得这篇写的很好，有时间要好好再看一看<a href="http://blog.csdn.net/it_man/article/details/4402245" target="_blank" rel="external">http://blog.csdn.net/it_man/article/details/4402245</a></p>
<h2 id="AOP（面向切面编程）">AOP（面向切面编程）</h2><p>面向切面编程（也叫面向方面编程），是目前软件开发中的一个热点，也是Spring框架中的一个重要内容。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。<br>主要包括以下几个方面</p>
<ol>
<li>切面Aspect</li>
<li>连接点Joinpoint</li>
<li>通知Advice</li>
<li>切入点Pointcut</li>
<li>目标对象Target Object</li>
<li>AOP代理AOP Proxy</li>
</ol>
<p>具体可参考<a href="http://blog.csdn.net/wangpeng047/article/details/8556800" target="_blank" rel="external">http://blog.csdn.net/wangpeng047/article/details/8556800</a><br>也可参考<a href="http://blog.csdn.net/moreevan/article/details/11977115" target="_blank" rel="external">http://blog.csdn.net/moreevan/article/details/11977115</a></p>
<h1 id="java注解">java注解</h1><p>使用spring最大的感受就是大量的注解，很方便，但是java基础不怎么样的我就要好好复习一下注解的知识了</p>
<h2 id="何为注解">何为注解</h2><p> 说起注解，得先提一提什么是元数据(metadata)。所谓元数据就是数据的数据。也就是说，元数据是描述数据的。就象数据表中的字段一样，每个字段描述了这个字段下的数据的含义。而J2SE5.0中提供的注解就是java源代码的元数据，也就是说注解是描述java源代码的。在J2SE5.0中可以自定义注解。使用时在@后面跟注解的名字。</p>
<h2 id="预定义的注解（Override、Deprecated和SuppressWarnings）">预定义的注解（Override、Deprecated和SuppressWarnings）</h2><h3 id="Override">Override</h3><p>这个注解的作用是标识某一个方法是否覆盖了它的父类的方法，在eclipse下开发，当你继承了一个类或接口，开发工具会自动添加出这个东西。它的主要作用就是防止继承方法名字写错，这样是不会报错的，只会认为你添加了子类的新方法而已，结果就是没有覆盖父类方法，而且编译也不会报错。</p>
<h3 id="Deprecated">Deprecated</h3><p>这个注解是一个标记注解。所谓标记注解，就是在源程序中加入这个标记后，并不影响程序的编译，但有时编译器会显示一些警告信息。</p>
<p>那么Deprecated注解是什么意思呢？如果你经常使用eclipse等IDE编写java程序时，可能会经常在属性或方法提示中看到这个词。如果某个类成员的提示中出现了个词，就表示这个并不建议使用这个类成员。因为这个类成员在未来的JDK版本中可能被删除。之所以在现在还保留，是因为给那些已经使用了这些类成员的程序一个缓冲期。如果现在就去了，那么这些程序就无法在新的编译器中编译了。</p>
<h3 id="SuppressWarnings">SuppressWarnings</h3><p>这个世界的事物总是成对出现。即然有使编译器产生警告信息的，那么就有抑制编译器产生警告信息的。</p>
<p>SuppressWarnings注解就是为了这样一个目的而存在的。</p>
<h3 id="自定义注解">自定义注解</h3><ul>
<li>元注解<br>注解可以用于注解类（annotate Classes）<br>可以用于注解接口(annotate Interfaces)<br>可以用于注解枚举类型(annotate Enums)<br>因此注解同样也可以用于注解注解（annotate Annotations）<br>它们是Target、Retention、Documented和Inherited。</li>
<li>注解的本质：注解是一种类型</li>
</ul>
<p>具体可参考<a href="http://blog.csdn.net/rj042/article/details/6399965" target="_blank" rel="external">http://blog.csdn.net/rj042/article/details/6399965</a></p>
<h1 id="spring_注解">spring 注解</h1><p>这个部分我始终只是能做到使用，但是具体原理始终没有理解透彻，这里先记下个地址留着以后回头来重新理解<a href="http://blog.csdn.net/hjm4702192/article/details/9420297?utm_source=tuicool" target="_blank" rel="external">http://blog.csdn.net/hjm4702192/article/details/9420297?utm_source=tuicool</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>公司另一个项目组换框架，将要换成spring的框架，正好我之前做的项目用的spring，但是我本身也没有理解的多透彻。明天需要我去简单培训一下，所以我就借此机会好好复习一下了</p>
<h1 id="spring核心思想">spring核心思想</h1><h2 id="IOC（控制反转）">IOC（控制反转）</h2><p>  Spring容器来实现这些相互依赖对象的创建、协调工作。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了（IOC、DI）。<br>]]>
    
    </summary>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="工作总结" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速搭建express]]></title>
    <link href="http://yoursite.com/2015/05/17/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAexpress/"/>
    <id>http://yoursite.com/2015/05/17/快速搭建express/</id>
    <published>2015-05-17T13:28:17.000Z</published>
    <updated>2015-05-17T13:32:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="安装express">安装express</h1><blockquote>
<p>npm install -g express</p>
</blockquote>
<p>不过由于express升级到了4.X版本，与之前版本差异性有些大，所以，还需要安装express-generator的包才可以</p>
<blockquote>
<p>npm install -g express-generator</p>
</blockquote>
<p>然后执行<br>express -V查看版本号，注意此处-V是大写字母<br><a id="more"></a></p>
<p>安装完成以后，进入你想要放项目的目录，</p>
<blockquote>
<p>express demo-project</p>
</blockquote>
<p>就会生成一个空的express项目，包含各种文件夹，然后进入此文件夹</p>
<blockquote>
<p>npm install</p>
</blockquote>
<p>执行自动的更新</p>
<p>至此一个完整的express就完成了，打开app.js<br>文件，在最后添加一句</p>
<blockquote>
<p>app.listen(3000)</p>
</blockquote>
<p>然后在本地浏览器输入localhost:3000，就能能够看见结果了。</p>
<p>网上的教程多是在express3.x下的，其中的转变可以参考这个博客<br><a href="http://www.cnblogs.com/haogj/p/3985438.html" target="_blank" rel="external">http://www.cnblogs.com/haogj/p/3985438.html</a></p>
<h1 id="app-js内容详解">app.js内容详解</h1><p>一个新建立的express工程，app.js里面会自动生成如下的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> favicon = <span class="built_in">require</span>(<span class="string">'static-favicon'</span>);</span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> routes = <span class="built_in">require</span>(<span class="string">'./routes/index'</span>);</span><br><span class="line"><span class="keyword">var</span> users = <span class="built_in">require</span>(<span class="string">'./routes/users'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// view engine setup</span></span><br><span class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>));</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</span><br><span class="line"></span><br><span class="line">app.use(favicon());</span><br><span class="line">app.use(logger(<span class="string">'dev'</span>));</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded());</span><br><span class="line">app.use(cookieParser());</span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'public'</span>)));</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, routes);</span><br><span class="line">app.use(<span class="string">'/users'</span>, users);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// catch 404 and forwarding to error handler</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not Found'</span>);</span><br><span class="line">    err.status = <span class="number">404</span>;</span><br><span class="line">    next(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// error handlers</span></span><br><span class="line"><span class="comment">// development error handler</span></span><br><span class="line"><span class="comment">// will print stacktrace</span></span><br><span class="line"><span class="keyword">if</span> (app.get(<span class="string">'env'</span>) === <span class="string">'development'</span>) &#123;</span><br><span class="line">    app.use(<span class="function"><span class="keyword">function</span><span class="params">(err, req, res, next)</span> </span>&#123;</span><br><span class="line">        res.status(err.status || <span class="number">500</span>);</span><br><span class="line">        res.render(<span class="string">'error'</span>, &#123;</span><br><span class="line">            message: err.message,</span><br><span class="line">            error: err</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// production error handler</span></span><br><span class="line"><span class="comment">// no stacktraces leaked to user</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span><span class="params">(err, req, res, next)</span> </span>&#123;</span><br><span class="line">    res.status(err.status || <span class="number">500</span>);</span><br><span class="line">    res.render(<span class="string">'error'</span>, &#123;</span><br><span class="line">        message: err.message,</span><br><span class="line">        error: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure>
<p>下面针对此代码里出现的部分进行一些解释</p>
<ul>
<li>require();<br>模块引用（这个深入探究好像也挺多东西，在这就不详解了）</li>
<li><p>use()<br>加载中间件（这个也挺复杂，我个人也还没理解好）</p>
</li>
<li><p>view engine setup<br>模板引擎，表明要使用的模板引擎是 ejs，页面模板在 views 子目录下。在 routes/index.js 的<br>exports.index 函数中通过如下语句调用模板引擎：<br>res.render(‘index’, { title: ‘Express’ });<br>res.render 的功能是调用模板引擎，并将其产生的页面直接返回给客户端。它接受<br>两个参数，第一个是模板的名称，即 views 目录下的模板文件名，不包含文件的扩展名；第<br>二个参数是传递给模板的数据，用于模板翻译。index.ejs 内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="tag">&lt;<span class="title">%=</span> <span class="attribute">title</span> %&gt;</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>Welcome to <span class="tag">&lt;<span class="title">%=</span> <span class="attribute">title</span> %&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码其中有两处 &lt;%= title %&gt;，用于模板变量显示，它们在模板翻译时会被替换<br>成 Express，因为 res.render 传递了 { title: ‘Express’ }。</p>
<h2 id="使用的中间件">使用的中间件</h2><ul>
<li>favicon()<br>favicon是网站的小图标，显示在浏览器的地址栏和收藏栏里。为了得到这个图标，浏览器会请求/favicon.ico文件。一般来说，最好尽快响应对favicon文件的请求，这样程序的其他部分就可以忽略它们了。</li>
<li>logger()<br>logger()是一个灵活的请求日志中间件，带有可定制的日志格式。它还能缓冲日志输出，减少写硬盘的次数，并且如果你想把日志输出到控制台之外的其他地方，比如文件或socket中，还可以指定日志流</li>
<li>bodyParser()<br> 解析请求主体<br>所有Web程序都需要接受用户的输入。假设你要用HTML标签<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"file"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>接受用户上传的文件。用一行代码添加bodyParser()中间件就全齐了。这是个非常有用的组件，实际上它整合了其他三个更小的组件：json(),urlencoded(), 和 multipart()。</p>
<ul>
<li>cookieParser()<br> 解析HTTP cookie<br> cookie解析器支持常规cookie、签名cookie和特殊的JSON cookie。req.cookies默认是用常规未签名cookie组装而成的。如果你想支持session()中间件要求的签名cookie，在创建cookieParser()实例时要传入一个加密用的字符串。<br><strong>在服务器端设定cookie中间件</strong><blockquote>
<p>cookieParser()不会为设定出站cookie提供任何帮助。<br>为此你应该用res.setHeader()函数设定名为Set-Cookie的响应头。<br>Connect针对Set-Cookie响应头这一特殊情况为Node默认的res.setHeader()函数打了补丁，所以它可以按你期望的方式工作。</p>
</blockquote>
</li>
<li><p>express.static(path.join(_dirname,’public’));<br>静态文件服务<br>static()中间件实现了一个高性能的、灵活的、功能丰富的静态文件服务器，支持HTTP缓存机制、范围请求等。更重要的是，它有对恶意路径的安全检查，默认不允许访问隐藏文件（文件名以.开头），会拒绝有害的null字节。static()本质上是一个非常安全的、完全能胜任的静态文件服务中间件，可以保证跟目前各种HTTP客户端的兼容。</p>
<h2 id="其他中间件">其他中间件</h2></li>
<li><p>limit()：请求主体的限制<br>只解析请求主体是不够的。开发人员还需要正确分类可接受的请求，并在恰当的时机对它们加以限制。设计limit()中间件组件的目的是帮助过滤巨型的请求，不管它们是不是恶意的。<br>比如说，一个无心的用户上传照片时可能不小心发送了一个未经压缩的RAW图片，里面有几百兆的数据，或者一个恶意用户可能会创建一个超大的JSON字符串把bodyParser()锁住，并最终锁住V8的JSON.parse()方法。你必须把服务器配置好，让它能应对这些状况。</p>
</li>
<li><p>query()：查询字符串解析<br>bodyParser()，可以解析表单的POST请求，但GET请求怎么解析呢？用query()中间件。它解析查询字符串，为程序提供req.query对象。对于用过PHP的开发人员而言，它就跟$_GET关联数组类似。query()跟bodyParser()一样，也要放在其他会用到它的中间件前面。</p>
</li>
<li><p>methodOverride()：伪造HTTP方法<br>当你构建一个使用特殊HTTP谓词的服务器时，比如PUT或DELETE，在浏览器中会出现一个有趣的问题。浏览器的<form>只能GET或POST，所以你在程序中也不能使用其他方法。<br>一种常见的解决办法是添加一个</form></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">hidden</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将其值设定为你想用的方法名，然后让服务器检查那个值并“假装”它是这个请求的请求方法。methodOverride()是这项技术中服务器这边的解决办法。</p>
<ul>
<li><p>vhost()：虚拟主机<br>vhost()（虚拟主机）中间件是一种通过请求头Host路由请求的简单、轻量的办法。这项任务通常是由反向代理完成的，可以把请求转发到运行在不同端口上的本地服务器那里。<br>vhost()组件在同一个Node进程中完成这一操作，它将控制权交给跟vhost实例关联的Node HTTP服务器。</p>
</li>
<li><p>session()：会话管理</p>
</li>
<li>csrf()：跨站请求伪造防护</li>
<li>errorHandler()：开发错误处理</li>
<li>directory()：目录列表</li>
<li>basicAuth()：HTTP基本认证</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="安装express">安装express</h1><blockquote>
<p>npm install -g express</p>
</blockquote>
<p>不过由于express升级到了4.X版本，与之前版本差异性有些大，所以，还需要安装express-generator的包才可以</p>
<blockquote>
<p>npm install -g express-generator</p>
</blockquote>
<p>然后执行<br>express -V查看版本号，注意此处-V是大写字母<br>]]>
    
    </summary>
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[package.json详解]]></title>
    <link href="http://yoursite.com/2015/05/16/package-json%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2015/05/16/package-json详解/</id>
    <published>2015-05-16T02:12:41.000Z</published>
    <updated>2015-05-16T05:42:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="package-json文件详解">package.json文件详解</h1><h2 id="name">name</h2><p><strong>必须</strong> 字段<br>下面是官方的建议：</p>
<ul>
<li>名字里不要再包含”js”和”node”，因为默认NPM包就是node.js程序，不过你可以通过engines字段来指定。</li>
<li>名字将会被作为url的一部分，所有要符合http url的一般命名规则，不能包含url非法字符，也不能以.和_开头。</li>
<li>名字也将作为require()命令的参数，所以应该尽量简明。</li>
<li>如果包要发布到NPM平台上的话，最好先检查下有没有重名, 并且字母只能全部小写。<br>新版本的NPM可以指定scope, 名字可以加前缀标识，如@ijse/mypackage。</li>
</ul>
<a id="more"></a>
<h2 id="version">version</h2><p><strong>必须</strong> 字段<br>在package.json中最重要的就是name和version字段。他们都是必须的，如果没有就无法install。name和version一起组成的标识在假设中是唯一的。改变包应该同时改变version。</p>
<p>version必须能被 <a href="https://github.com/npm/node-semver" target="_blank" rel="external">node-semver</a>解析，它被包在npm的依赖中。（要自己用可以执行npm install semver）</p>
<p>更多可用的“数字”或者“范围”见<a href="https://docs.npmjs.com/misc/semver" target="_blank" rel="external">semver(7)</a>.</p>
<h2 id="description">description</h2><p>可选字段<br>包的描述信息，将会在npm search的返回结果中显示，以帮助用户选择合适的包。</p>
<h2 id="keywords">keywords</h2><p>可选字段<br>包的关键词信息，是一个字符串数组，同上也将显示在npm search的结果中。</p>
<h2 id="homepage">homepage</h2><p>可选字段<br><strong>没有</strong> <a href="http://等带协议前缀的URL。" target="_blank" rel="external">http://等带协议前缀的URL。</a></p>
<h2 id="bugs">bugs</h2><p>可选字段<br>你项目的提交问题的url和（或）邮件地址。</p>
<blockquote>
<p>bugs: {<br> “url”: “<a href="http://github.com/ijse/project/issues" target="_blank" rel="external">http://github.com/ijse/project/issues</a>“,<br> “email”: “my@ijser.cn”<br>}</p>
</blockquote>
<h2 id="license">license</h2><p>可选字段<br>包的开源协议名称<br>如果是使用一个普遍的license，比如BSD-3-Clause或MIT，直接使用：</p>
<blockquote>
<p>{ “license” :”BSD-3-Clause”}</p>
</blockquote>
<p>如果你有更复杂的许可条件，或者想要提供给更多地细节，可以这样:</p>
<blockquote>
<p>“licenses” : [<br>  { “type” : “MyLicense”<br>  , “url” : “<a href="http://github.com/owner/project/path/to/license" target="_blank" rel="external">http://github.com/owner/project/path/to/license</a>“<br>  }<br>]</p>
</blockquote>
<h2 id="author">author</h2><p>可选字段<br>包的作者，可以是字符串或对象</p>
<blockquote>
<p>author: {<br>  “name”: “ijse”,<br>  “email”: “my@ijse.cn”,<br>  “url”: “<a href="http://www.ijser.cn" target="_blank" rel="external">http://www.ijser.cn</a>“<br>}</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>author: “ijse <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x6d;&#121;&#64;&#x69;&#x6a;&#115;&#x65;&#x72;&#46;&#99;&#x6e;">&#x6d;&#121;&#64;&#x69;&#x6a;&#115;&#x65;&#x72;&#46;&#99;&#x6e;</a> (<a href="http://www.ijser.cn" target="_blank" rel="external">http://www.ijser.cn</a>)”  </p>
</blockquote>
<h2 id="contributors">contributors</h2><p>可选字段<br>包的贡献者，是一个数组</p>
<h2 id="files">files</h2><p>可选字段<br>包所包含的所有文件，可以取值为文件夹。</p>
<p>通常我们还是用.npmignore来去除不想包含到包里的文件。</p>
<h2 id="main">main</h2><p>可选字段<br>这个字段的值是你程序主入口模块的ID。如果其他用户需要你的包，当用户调用require()方法时，返回的就是这个模块的导出（exports）。</p>
<h2 id="bin">bin</h2><p>可选字段<br>如果你的包里包含可执行文件，通过设置这个字段可以将它们包含到系统的PATH中，这样直接就可以运行，很方便。如：</p>
<blockquote>
<p>“bin”: {<br>  “iapp”: “./cli.js”<br>}</p>
</blockquote>
<p>当包被安装后，NPM将创建一个cli.js文件的链接到/usr/local/bin/iapp下。</p>
<h2 id="man">man</h2><p>为系统的man命令提供帮助文档, 如：</p>
<blockquote>
<p>“man”: “./man/doc.1”</p>
</blockquote>
<p>帮助文件的文件名必须以数字结尾，如果是压缩的，需要以.gz结尾。</p>
<p>如果是字符串数组：</p>
<blockquote>
<p>“name”: “foo”,<br>“man”: [“./man/foo.1”, “./man/bar.1”, “./man/foo.2” ]</p>
</blockquote>
<p>则分别可以man foo, man foo-bar, man 2 foo来查看。</p>
<h2 id="directories">directories</h2><p>CommonJS包所要求的目录结构信息，目前除了告诉别人你的程序目录结构，貌似没有别的什么用。<br>下级字段可以是：lib, bin, man, doc, example。 每个都是字符串</p>
<h2 id="repository">repository</h2><p>可选字段<br>用于指示代码存放的位置</p>
<blockquote>
<p>“repository” :<br>  { “type” : “git”<br>  , “url” : “<a href="http://github.com/npm/npm.git" target="_blank" rel="external">http://github.com/npm/npm.git</a>“<br>  }<br>“repository” :<br>  { “type” : “svn”<br>  , “url” : “<a href="http://v8.googlecode.com/svn/trunk/" target="_blank" rel="external">http://v8.googlecode.com/svn/trunk/</a>“<br>  }</p>
</blockquote>
<h2 id="script">script</h2><p>“scripts”是一个由脚本命令组成的hash对象，他们在包不同的生命周期中被执行。key是生命周期事件，value是要运行的命令。</p>
<p>参见 <a href="https://docs.npmjs.com/misc/scripts" target="_blank" rel="external">npm-scripts(7)</a></p>
<h2 id="config">config</h2><p>可选字段<br>添加一些设置，可以供scripts读取用，同时这里的值也会被添加到系统的环境变量中。</p>
<blockquote>
<p>“name”: “foo”,<br>“config”: {<br>  “port”: “8080”<br>}</p>
</blockquote>
<p>npm start的时候会读取到npm_package_config_port环境变量。</p>
<p>同时也可以使用npm config命令来修改设置：</p>
<blockquote>
<p>npm config set foo:port 8001  </p>
</blockquote>
<h2 id="dependencies">dependencies</h2><p>可选字段<br>指定依赖的其它包，这些依赖是指包发布后正常执行时所需要的，如果是开发中依赖的包，可以在devDependencies设置。</p>
<p>通常使用下面命令来安装：</p>
<blockquote>
<p>npm install —save otherpackage  </p>
</blockquote>
<p>形式可以有如下多种：</p>
<ul>
<li>version 严格匹配某个版本</li>
<li><blockquote>
<p>version 必须大于某个版本</p>
</blockquote>
</li>
<li><blockquote>
<p>=version</p>
</blockquote>
</li>
<li>&lt;version</li>
<li>&lt;=version</li>
<li>~version 大概匹配某个版本</li>
<li>^version 兼容某个版本</li>
<li>1.2.x 可以是1.2.0, 1.2.1等等，但不能是1.3.0</li>
<li>http://… 指定tarball的url地址</li>
<li><ul>
<li>任何版本都可以</li>
</ul>
</li>
<li>“” 同上</li>
<li>version1 - version2 &gt;=version1 &lt;=version2</li>
<li>range1 || range2 满足range1 或range2</li>
<li>git://… git地址</li>
<li>user/repo 同上</li>
<li>tag 指定某个tag的版本</li>
<li>path/path 本地包所有文件夹</li>
</ul>
<p>下面都是可以用的：</p>
<blockquote>
<p>{ “dependencies” :<br>  { “foo” : “1.0.0 - 2.9999.9999”<br>  , “bar” : “&gt;=1.0.2 <2.1.2" ,="" "baz"="" :="" "="">1.0.2 &lt;=2.3.4”<br>  , “boo” : “2.0.1”<br>  , “qux” : “<1.0.0 ||="">=2.3.1 <2.4.5 ||="">=2.5.2 &lt;3.0.0”<br>  , “asd” : “<a href="http://asdf.com/asdf.tar.gz" target="_blank" rel="external">http://asdf.com/asdf.tar.gz</a>“<br>  , “til” : “~1.2”<br>  , “elf” : “~1.2.3”<br>  , “two” : “2.x”<br>  , “thr” : “3.3.x”<br>  , “lat” : “latest”<br>  , “dyl” : “file:../dyl”<br>  }<br>}</2.4.5></1.0.0></2.1.2"></p>
</blockquote>
<p>Git URL可以有如下种形式：</p>
<blockquote>
<p>git://github.com/user/project.git#commit-ish<br>git+ssh://user@hostname:project.git#commit-ish<br>git+ssh://user@hostname/project.git#commit-ish<br>git+<a href="http://user@hostname/project/blah.git#commit-ish" target="_blank" rel="external">http://user@hostname/project/blah.git#commit-ish</a><br>git+<a href="https://user@hostname/project/blah.git#commit-ish" target="_blank" rel="external">https://user@hostname/project/blah.git#commit-ish</a>  </p>
</blockquote>
<h2 id="devdependencies">devdependencies</h2><p>这些依赖只有在开发时候才需要。</p>
<blockquote>
<p>npm install —save-dev mypack  </p>
</blockquote>
<h2 id="peerDependencies">peerDependencies</h2><p>相关的依赖，如果你的包是插件，而用户在使用你的包时候，通常也会需要这些依赖（插件），那么可以将依赖列到这里。</p>
<p>举个例子，如karma, 它的package.json中有设置：</p>
<blockquote>
<p>“peerDependencies”: {<br>  “karma-jasmine”: “~0.1.0”,<br>  “karma-requirejs”: “~0.2.0”,<br>  “karma-coffee-preprocessor”: “~0.1.0”,<br>  “karma-html2js-preprocessor”: “~0.1.0”,<br>  “karma-chrome-launcher”: “~0.1.0”,<br>  “karma-firefox-launcher”: “~0.1.0”,<br>  “karma-phantomjs-launcher”: “~0.1.0”,<br>  “karma-script-launcher”: “~0.1.0”<br>}</p>
</blockquote>
<p>这些都是karma的相关插件，一般使用karma的时候都会需要。</p>
<h2 id="bundledDependencies">bundledDependencies</h2><p>绑定的依赖包，发布的时候这些绑定包也会被一同发布。</p>
<h2 id="optionalDependencies">optionalDependencies</h2><p>即使这些依赖没有，也可以正常安装使用</p>
<h2 id="engines">engines</h2><p>指定包运行的环境</p>
<blockquote>
<p>“engines”: {<br>  “node”: “&gt;=0.10.3 &lt; 0.12”,<br>  “npm”: “~1.0.20”<br>}</p>
</blockquote>
<h2 id="engineStrict">engineStrict</h2><p>设置为true强制限定 engine</p>
<h2 id="os">os</h2><p>指定你的包可以在哪些系统平台下运行。</p>
<blockquote>
<p>“os”: [ “darwin”, “linux”, “!win32” ]</p>
</blockquote>
<p>即可以在darwin和linux平台下运行，而不能在win32下。这里设定的取值是来自process.platform的。</p>
<h2 id="cpu">cpu</h2><p>可以指定包运行的cpu架构，如</p>
<blockquote>
<p>“cpu”: [ “x64”, “!arm” ]</p>
</blockquote>
<p>取值来自process.arch。</p>
<h2 id="preferGlobal">preferGlobal</h2><p>如果你的包是命令行运行的，那可以将其设置为true建议用户全局(npm install -g)安装。但它并不强制用户。</p>
<h2 id="private">private</h2><p>设为true这个包将不会发布到NPM平台下。</p>
<h2 id="publishConfig">publishConfig</h2><p>这个字段用于设置发布时候的一些设定。尤其方便你希望发布前设定指定的tag或registry。</p>
<p>也可以设定其它子字段，但只有tag和registry会影响到发布。</p>
<h2 id="默认值">默认值</h2><ul>
<li><p>“scripts”: { “start”: “node server.js” } 如果在项目根目录下含有server.js文件，则NPM会自动设置此值。</p>
</li>
<li><p>“scripts”: { “preinstall”: “node-gyp rebuild” }</p>
</li>
</ul>
<p>如果在项目根目录下含有binding.gyp文件，则NPM会自动设置此值。</p>
<ul>
<li>“contributors”: […]</li>
</ul>
<p>如果项目根目录下含有AUTHORS文件，则NPM会自动将每一行以Name <email> (url)的格式读取并设定此字段。</email></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="package-json文件详解">package.json文件详解</h1><h2 id="name">name</h2><p><strong>必须</strong> 字段<br>下面是官方的建议：</p>
<ul>
<li>名字里不要再包含”js”和”node”，因为默认NPM包就是node.js程序，不过你可以通过engines字段来指定。</li>
<li>名字将会被作为url的一部分，所有要符合http url的一般命名规则，不能包含url非法字符，也不能以.和_开头。</li>
<li>名字也将作为require()命令的参数，所以应该尽量简明。</li>
<li>如果包要发布到NPM平台上的话，最好先检查下有没有重名, 并且字母只能全部小写。<br>新版本的NPM可以指定scope, 名字可以加前缀标识，如@ijse/mypackage。</li>
</ul>]]>
    
    </summary>
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
      <category term="package.json" scheme="http://yoursite.com/tags/package-json/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo博客建立全过程]]></title>
    <link href="http://yoursite.com/2015/05/15/hexo-procedure/"/>
    <id>http://yoursite.com/2015/05/15/hexo-procedure/</id>
    <published>2015-05-15T13:19:26.000Z</published>
    <updated>2015-05-15T16:45:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>忘记了具体是怎么接触到nodejs的，只是感觉通过nodejs真切感觉到了，以后前端开发将会是趋势，所以也想着加入到前端开发的行列中来，在网上查询nodejs的学习路径，看见了使用Hexo搭建个人博客这么一条，于是便学着搭建起来一个，顺便以此作为学习的起点，网上的教程博客很多，一下的只是我个人操作的时候使用到 地方，趁着刚刚做完，还记得不少，就赶紧记录了下来。<br>顺便一提，由于nodejs的开发环境推荐使用Linux或者Mac OS X下进行，同时本人穷小子一个，所以就毫不犹豫的自己装了个虚拟机，在linux上进行开发了，所以一下所处环境都是在虚拟机里的ubuntu下进行的</p>
<a id="more"></a>
<h1 id="github">github</h1><p>github相信即使没用过，大家也都听过，目前非常多且著名的开源项目都托管在这里，而且由于其免费提供300M空间，目前在天朝也没有被墙，也能顺便学习一下git，所以想要找到一个免费的静态博客托管服务器，github毫无疑问是最佳选择之一。</p>
<h2 id="配置和使用_github">配置和使用 github</h2><p>首先，注册一个<a href="https://github.com/" target="_blank" rel="external">github</a>帐号</p>
<h3 id="配置SSH_keys">配置SSH keys</h3><p>我们如何让本地git项目与远程的github建立联系呢？用SSH keys。</p>
<blockquote>
<p>cd ~/. ssh   检查本机的ssh密钥<br>ssh-keygen -t rsa -C “邮件地址@youremail.com” 生成新密钥<br>Generating public/private rsa key pair.<br>Enter file in which to save the key &gt;(/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</p>
<p>注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；<br>注意2: 此处的「-C」的是大写的「C」</p>
</blockquote>
<p>然后系统会要你输入密码：</p>
<blockquote>
<p>Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;<br>Enter same passphrase again:&lt;再次输入加密串&gt;</p>
</blockquote>
<p>如果出现下面的画面，就是配置成功了<br><img src="http://pic.yupoo.com/vankos_v/DKi6S7PO/lpjsl.png" alt="密钥生成成功"></p>
<h3 id="添加SSH_Key到GitHub">添加SSH Key到GitHub</h3><ul>
<li>打开本地~/.ssh/id_rsa.pub文件。此文件里面内容为刚才生成人密钥。准确的复制这个文件的内容，才能保证设置的成功。</li>
<li>登陆github系统。点击右上角的 Account Settings—-&gt;SSH Public keys —-&gt; add another public keys</li>
<li>把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了</li>
</ul>
<p>可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：</p>
<blockquote>
<p>$ ssh -T git@github.com</p>
</blockquote>
<p>如果是下面的反馈：</p>
<blockquote>
<p>The authenticity of host ‘github.com (207.97.227.239)’ can’t be &gt;established.<br>RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.<br>Are you sure you want to continue connecting (yes/no)?</p>
</blockquote>
<p>不要紧张，输入yes就好，然后会看到：</p>
<blockquote>
<p>Hi cnfeat! You’ve successfully authenticated, but GitHub does not &gt;provide shell access.</p>
</blockquote>
<p>最后</p>
<blockquote>
<p>git config —global user.name “cnfeat”//用户名<br>git config —global user.email  “cnfeat@gmail.com”//填写自己的邮箱</p>
</blockquote>
<p>至此，与github的链接建立完成</p>
<h3 id="使用GitHub_Pages建立博客">使用GitHub Pages建立博客</h3><p>与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务，GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.io这样的用户&amp;组织页（站），另一种是依附项目的pages。</p>
<p>想建立个人博客是用的第一种，形如cnfeat.github.io这样的可访问的站，每个用户名下面只能建立一个。<br>具体流程可以参考<a href="http://www.pchou.info/web-build/2013/01/05/build-github-blog-page-02.html" target="_blank" rel="external">一步步在GitHub上创建博客主页(2)</a></p>
<h1 id="nodejs">nodejs</h1><p>目前国内比较活跃的是<a href="https://cnodejs.org/" target="_blank" rel="external">Cnode社区</a>，有兴趣的可以去转转。<br>我是通过nvm安装node的</p>
<blockquote>
<p>cd ~/git<br>git clone <a href="https://github.com/cnpm/nvm.git" target="_blank" rel="external">https://github.com/cnpm/nvm.git</a><br>source ~/git/nvm/nvm.sh</p>
</blockquote>
<p>然后就可以安装任意版本的nodejs了</p>
<blockquote>
<p>nvm install 0.12.0</p>
</blockquote>
<p>具体可参考社区里新手教学的<a href="http://fengmk2.com/blog/2014/03/node-env-and-faster-npm.html" target="_blank" rel="external">快速搭建 Node.js / io.js 开发环境以及加速 npm</a></p>
<h1 id="hexo">hexo</h1><p>Hexo的作者是<a href="https://github.com/tommy351" target="_blank" rel="external">tommy351</a>，根据<a href="http://hexo.io/docs/index.html" target="_blank" rel="external">官方介绍</a>，Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。</p>
<h2 id="安装hexo">安装hexo</h2><p>找到一个路径，新建一个文件夹，比如我的就叫做Hexo。进入此路径后</p>
<blockquote>
<p>npm install -g hexo<br>hexo init</p>
</blockquote>
<p>成功后此路径下就会多出一个完整的hexo项目。</p>
<blockquote>
<p>hexo g<br>hexo s</p>
</blockquote>
<p>浏览器输入<a href="http://localhost:4000，查看搭建效果。" target="_blank" rel="external">http://localhost:4000，查看搭建效果。</a></p>
<p>PS：这个安装方法我使用后只能在这个Hexo目录下有效，这么设置成全局的我没有研究<br>常用命令如下：</p>
<blockquote>
<p>hexo new “postName” #新建文章<br>hexo new page “pageName” #新建页面<br>hexo generate #生成静态页面至public目录<br>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy #将.deploy目录部署到GitHub</p>
</blockquote>
<p>也可以简写：</p>
<blockquote>
<p>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy</p>
</blockquote>
<h2 id="克隆主题">克隆主题</h2><p>成功以后，你会发现在你的目录下有个themes的文件夹，这个就是hexo的主题，你可以通过修改配置文件_config.yml中的theme的值来确定使用哪个主题。主题的下载地址是<a href="http://hexo.io/themes/,当然也有很多不错的主题并没有在这个页面里，需要你去一下论坛或什么地方找了，比如我现在使用的主题是https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">http://hexo.io/themes/,当然也有很多不错的主题并没有在这个页面里，需要你去一下论坛或什么地方找了，比如我现在使用的主题是https://github.com/litten/hexo-theme-yilia</a></p>
<p>具体使用起来很简单</p>
<blockquote>
<p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="external">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</p>
</blockquote>
<p>然后你的themes文件夹下就多了个yilia的文件夹，修改_config.yml中的theme的就可以选定你要用的主题了，你可以多下载几个都试试效果，然后再确定最后使用谁的。<br>最后推荐一个学习hexo具体配置的地方<br><a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">http://zipperary.com/categories/hexo/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>忘记了具体是怎么接触到nodejs的，只是感觉通过nodejs真切感觉到了，以后前端开发将会是趋势，所以也想着加入到前端开发的行列中来，在网上查询nodejs的学习路径，看见了使用Hexo搭建个人博客这么一条，于是便学着搭建起来一个，顺便以此作为学习的起点，网上的教程博客很多，一下的只是我个人操作的时候使用到 地方，趁着刚刚做完，还记得不少，就赶紧记录了下来。<br>顺便一提，由于nodejs的开发环境推荐使用Linux或者Mac OS X下进行，同时本人穷小子一个，所以就毫不犹豫的自己装了个虚拟机，在linux上进行开发了，所以一下所处环境都是在虚拟机里的ubuntu下进行的</p>]]>
    
    </summary>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人博客开通]]></title>
    <link href="http://yoursite.com/2015/05/13/hello%20world/"/>
    <id>http://yoursite.com/2015/05/13/hello world/</id>
    <published>2015-05-12T16:10:11.000Z</published>
    <updated>2015-05-13T16:00:32.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xj22g.com1.z0.glb.clouddn.com/blog_dabai2.jpg" alt="大白"></p>
<a id="more"></a>
<p>对于一个不懂nodejs,不会linux，没用过github的小菜鸟，经过不懈的努力，终于成功搭建起了基于hexo的个人博客，作为一名程序员，怎能没有自己的个人博客？不过话说回来，人与人的差距真是很大啊，这些hexo主题作者一个比一个年轻，个个是大牛……<br>后续我会在这里详细记录下我的开发流程，在这里开始nodejs的学习之旅，也会在这里记录下我的学习与生活的点滴。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xj22g.com1.z0.glb.clouddn.com/blog_dabai2.jpg" alt="大白"></p>]]>
    
    </summary>
    
      <category term="hello world" scheme="http://yoursite.com/tags/hello-world/"/>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>